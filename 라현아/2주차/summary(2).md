# TeaNet 자료구조 STUDY: 2주차(2)

# PART 02 자료구조

## CHAPTER 07: 자료구조란?

- **자료구조 Data Structure**
    - 개발자가 데이터를 효율적으로 사용할 수 있도록 정리하는 방법
- *알고리즘 + 자료구조 = 프로그램*
- **추상 데이터 타입 Abstract**: 자료구조를 설명하는 데이터의 타입
    - 추상 데이터 타입을 실제로 구현한 결과 ⇒ 자료구조
- 분류
    - **선형 자료구조 Linear**: 데이터 요소를 순서대로 정렬
        - ex. 파이썬의 리스트: 각 요소의 앞과 뒤에 다른 요소가 있는 선형 자료구조
        - 백트래킹BackTracking없이 쉽게 순회 → 효율적
        - 요소 전체를 변경하는 작업 용이
    - **비선형 자료구조 Nonlinear**: 데이터 요소를 비연속적으로 연결
        - ex. 파이썬의 그래프: 각 요소가 다른 요소와 연결될 수 있는 비선형 자료구조
        - 원하는 요소에 접근하기 위해 백트래킹이나 재귀가 필요
        - 소셜 네트워크의 연결과 같은 데이터 저장
    
    ---
    
    - **정적 자료구조 Static**: 크기가 고정되어 있는 자료구조
        - 프로그램을 생성할 때 크기 정의
        - 한 번 정의하면 그 크기는 고정되어 바꿀 수 없지만, 안에 저장
        - 반드시 일정량의 메모리를 할당해야 한다
            - 할당한 메모리보다 사용하는 데이터 요소가 적다면 → 메모리 낭비
            - 처음 할당한 메모리보다 많은 요소 추가X
        - 요소를 추가하려면
            - 새로운 자료구조를 만들어
            - 기존 요소와 새로운 요소를 모두 담을 정도로 충분히 큰 메모리를 다시 할당
            - 기존 구조를 새 구조에 복사 + 새로운 요소도 함께 추가
        - 저장할 요소의 개수를 미리 알고 있고, 
        그 개수가 변하지 않는 상황
    - **동적 자료구조 Dynamic**: 크기가 바뀔 수 있는 자료구조
        - 자유롭게 크기를 바꿀 수 있음
            - 요소를 추가할 때: 컴퓨터가 추가로 메모리를 할당하고
            - 요소를 제거할 때: 메모리를 비워서 다른 데이터가 사용할 수 있도록 만듦
        - 크기 고정X → 효율적으로 요소를 추가/제거 가능 → 효율적인 메모리 사용
        - 요소에 접근하는 작업 느림
        - 일정 수의 요소를 저장한다고 할 때 정적 자료구조보다 더 많은 메모리 사용
        - 저장해야 할 데이터의 양을 특정할 수 없고,
        특히 메모리 공간이 한정적일 때
- 자료구조를 **순회Traverse** 한다
    - 자료구조의 첫 번째 요소에서 출발해 마지막 요소로 이동한다

## CHAPTER 08: 배열

- **리스트 List**
    - 순서가 있는 값을 저장하는 자료구조를 정의하는 추상 데이터 타입
        - 비어 있는 새로운 리스트를 만드는 동작
        - 비어 있는지를 확인하는 동작
        - 요소를 맨 앞에 추가하는 동작
        - 요소를 맨 뒤에 추가하는 동작
        - 인덱스를 통해 요소에 접근하는 동작
    - 파이썬의 리스트 ⇒ **이질 가변 길이 배열 Heterogeneous Variable-Length Array**
        - **가변 길이 배열 Variable-Length Array**
            - 생성한 뒤에 크기를 바꿀 수 O
        - **이질 배열 Heterogenous Array**
            - 여러 타입의 데이터를 담을 수 O
- **배열 Array**
    - 연속적인 메모리 블록에 인덱스와 함께 요소를 저장하는 자료구조
    - 동질적이며 정적이다
        - **동질적 자료구조 Homogeneous**
            - 정수나 문자열과 같이 한 가지의 데이터 타입만 담을 수 O
        - 정적 자료구조
            - 일단 생성하면 크기를 바꿀 수 X
    - 배열에 저장된 각 요소 → 인덱스 통해 접근
        - 배열의 첫 번째 인덱스: 보통 0(파이썬, C), 프로그래밍 언어에 따라 다른 인덱스 규칙을 사용하기도 함
        즉 언어 by 언어
        - 배열의 첫 번째 요소가 저장된 메모리 위치 ⇒ **시작 주소 Base Address**
        - `base_address + index * size_of_data_type`
            
            해당 배열의 데이터 타입이 차지하는 메모리에 인덱스를 곱한 다음, 이를 시작 주소에 더해 저장할 주소를 정함
            
    
    ---
    
    - **1차원 배열 One-Dimensional Array**
        
        ```python
        array = [1, 2, 3]
        print(array[0])
        ```
        
    - **다차원 배열 Multidimensional Array**
        
        ```python
        multi_array = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
        print(array[1][2])
        ```
        
    
    ---
    
    - 성능: 상수 시간
        - 정렬되지 않은 배열 탐색(요소 전체 순회), 어떤 형태로든 배열을 변경하는 작업: O(n)
        - 대부분 O(log n)
        - C와 같은 언어에서 배열에 요소를 추가할 때
            1. 배열에 쓸 메모리 블록을 새로 예약하고
            2. 기존 블록의 데이터 전체를 새 블록으로 복사한 다음
            3. 새로운 요소를 추가하고
            4. 기존 블록을 비우는 방식으로 동작
        - 파이썬 **과다 할당 Overallocation** → 리스트에 요소를 추가하는 작업을 효율적으로 처리
            - 배열에 필요 이상의 메모리를 예약하고
                
                배열이 실제로 요소를 얼마나 저장하는지<
                
                사용하지 않는 공간은 어느정도인지< 모니터링
                
        - 배열에 요소를 삽입하면 다른 요소의 인덱스가 전부 변하기 때문에
            
            요소의 인덱스를 유지하고 싶다면
            
            파이썬 딕셔너리 Python Dictionary 사용
            
- 배열 만들기
- 리스트의 결합
- 중복 요소 찾기
    - 리스트의 각 요소를 다른 요소와 비교하기
        - 두 번 중첩된 루프 필요
        - O(n**2)
    - 파이썬의 세트 타입 이용
        - 세트: 중복 요소를 포함할 수 없는 자료구조
- 두 리스트의 교집합 찾기
    - `list3 = [v for  v in list1 if v in list2]`
        
        파이썬의 in 키워드
        
        - 이터러블에서 값 탐색
        - 정렬되지 않은 리스트에서 값 탐색 → 선형 탐색
        
        즉, 리스트 축약 루프 안에서 in 키워드가 다시 루프를 실행 → O(n**2)