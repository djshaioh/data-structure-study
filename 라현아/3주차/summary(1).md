# TeaNet 자료구조 STUDY: 3주차(1)

## CHAPTER 09: 링크드 리스트

- **링크드 리스트 Linked List**
    - 추상 데이터 타입의 리스트를 구현한 자료구조 中 하나
    - 배열과 마찬가지로 앞이나 뒤에 요소를 추가-탐색-삭제 가능
    - 요소
        - 인덱스 X
        - 연속적인 메모리 블록에 저장되지 X
        - 노드의 체인 저장
    - **노드 Node**
        - 데이터를 보관하는 필드 + 다음 노드의 위치를 나타내는 **포인터 Pointer**
            - 각 노드의 포인터: 다음 노드의 주소를 가리킴 → 리스트의 모든 요소 연결
        - 즉, 링크드 리스트 ⇒ 노드의 체인, 노드를 연결하여 만든 리스트
        - 첫 번째 노드: **헤드 Head**, 마지막 노드: 테일 Tail
            - 테일: None을 가리키는 포인터 포함
    - 배열과 달리 비연속적인 메모리에도 저장 O
    - 요소를 삽입해도 다른 데이터를 밀어낼 필요 X
    
    ---
    
    - **단일 링크드 리스트 Singly Linked List**
        - 각 노드에 다음 요소를 가리키는 포인터만 있는 링크드 리스트
        - 헤드에서 시작해 테일을 향해 이동하는 것 외에는 할 수 있는 것 X
    - **이중 링크드 리스트 Doubly Linked List**
        - 각 노드에 다음 요소를 가리키는 포인터와 이전 요소를 가리키는 포인터가 모두 있는 링크드 리스트
        - 두 방향의 포인터를 통해 어느 방향으로든 이동 가능
        - 헤드에서 테일로 이동하는 것 뿐만 아니라 이전 노드로도 이동
    - **환형 링크드 리스트 Circular Linked List**
        - 테일에 헤드를 가리키는 포인터가 있어
            
            테일에서 헤드로 돌아올 수 O
            
        - 시작과 끝이 명확하지 않은 데이터를 반복적으로 순환하는 애플리케이션에 유용
    - *‘이 리스트에 **사이클Cycle**이 있다’*
        
        링크드 리스트의 어떤 노드에든 이전 노드를 가리키는 포인터가 있을 때
        
    
    ---
    
    - 성능
        - 링크드 리스트
            - 노드로 연결되어 있는 리스트를 선형 탐색해야만 원하는 요소에 접근 ⇒ O(n)
            - 노드를 추가하거나 제거하는 작업 ⇒ O(1)
                - 데이터를 자주 추가하거나 제거하는 알고리즘
            - 탐색 ⇒ O(n)
        - 배열
            - 접근 ⇒ O(1)
            - 추가/제거⇒ O(n)
            - 탐색 ⇒ O(n)
    - 단점
        - 반드시 각 노드에 다음 노드를 가리키는 포인터 有
            
            → 포인터 역시 리소스 必 → 배열보다 더 많은 메모리 사용
            
            ---
            
            노드 하나에 저장하는 데이터의 크기가 아주 작다면,
            
            예를 들어 노드 하나에 하나의 정수만 저장하는 링크드 리스트의 경우에는
            
            같은 데이터를 저장하는 배열의 2배에 달하는 메모리를 사용할 수도 O
            
        - **임의 접근 Random Access** 불가능
            - 임의 접근: 상수 시간 내에 무작위로 데이터에 접근하는 경우
            - 배열에서는 언제든 세 번째 요소에 접근할 수 있지만 링크드 리스트에서는 불가능
                
                반드시 헤드에서 시작해 각 포인터를 따라 움직이며 세 번째 요소에 도달할 때까지 이를 반복
                

---

- 링크드 리스트 구현
    - 방법 1. 링크드 리스트와 그 노드를 나타내는 클래스 정의
        - `Node` 객체 → 파이썬: 이 객체를 가리키는 포인터 반환
            - 포인터: 실제 데이터가 위치하고 있는 메모리 주소
            - cf. 클래스의 인스턴스(클래스에서 정의된 속성과 성질을 가진 실질적인 객체)와 참조 반환
            - 매직 메서드
            
            ```python
                def __str__ (self):
                    node = self.head
                    while node is not None:
                        print(node.data)
                        node = node.next
                    return "end"
            ```
            
        - 파이썬: 링크드 리스트 내장X 
        but 내부적으로 링크드 리스트를 사용하는 **디큐Deque**라는 자료구조 有
            
            → 링크드 리스트를 직접 작성하지 않고도 링크드 리스트의 효율성만 이용
            
            ```python
            from collections import deque
            
            d = deque()
            
            d.append('Harry')
            d.append('Potter')
            
            for item in d:
                print(item)
            ```
            
- 링크드 리스트에 사이클이 포함되어 있는지
    
    = 마지막 요소가 ‘다음’ 변수의 값으로 None이 아니라 리스트의 어떤 요소를 가리키는지
    
    - 링크드 리스드에서 사이클을 찾는 알고리즘
        - **토끼와 거북이 알고리즘 Tortoise-and-The-Hare Algorithm**
            - 두 가지 속도로 링크드 리스트를 순회하면서 현재 노드를 각각 변수 slow와 fast에 담음
            - 링크드 리스트라면: 결국 fast 변수가 slow 변수를 따라잡아 같은 값이 되는 때가 올 것
                - 그렇지 않고 마지막에 도달한다면 사이클 X

## CHAPTER 10: 스택

- **스택 Stack**
    - 가장 최근에 추가한 요소만 제거할 수 있는 선형 자료구조
    - 대표적인 **후입 선출 자료구조 (LIFO: Last-In, First-Out)**
        - 마지막에 추가한 요소부터 꺼낼 수 있는 자료구조
        - 반드시 순서를 따라야 하기 때문에 ⇒ **접근이 제한된 자료구조 Limited-Access**
    - 동작
        - **푸시Pushing**
            - 스택에 요소 추가
            - O(1)
        - **팝Popping**
            - 스택에 마지막으로 추가한 요소 꺼내기
            - O(1)
        - **픽Peeking**
            - 스택의 마지막에 있는 요소를 제거하지 않고 접근만 하기
    
    ---
    
    - **제한된 스택 Bounded**
        - 추가할 수 있는 요소의 수에 제한 有
    - **무제한 스택 Unbounded**
        - 추가할 수 있는 요소의 수에 제한 無
    
    ---
    
    - 스택에 데이터 추가/제거 → 효율적
        
        스택의 전체에 접근 → 비효율적
        
    - 스택의 각 요소를 출력
        - 방법 1. 스택에서 요소를 꺼내는 동시에 출력하기
            - O(n)
            - 스택과 순서가 반대인 리스트가 만들어지고
            - 모든 요소를 꺼낸 스택은 빈 상태가 됨
        - 방법 2. 원래 스택에서 요소를 꺼냄과 동시에 임시 스택에 넣기
            - 임시 스택에서 요소를 꺼내 원래 스택으로 되돌리는 동시에 출력
            - 데이터 전체를 임시 스택에 저장 → 더 많은 메모리
                - O(2n)
                - 배열에서의 요소 출력 시간 2배
    - 너비 우선 탐색 알고리즘
        
        → 트리와 그래프에서 데이터 탐색
        
    - 백트래킹 알고리즘 구현
    
    ---
    
    - 스택 만들기
        - 방법 1. Stack 클래스 만들고 배열 사용해 내부적으로 데이터 관리
        - 방법 2. 링크드 리스트를 사용해 Stack 클래스 만들고 푸시/팝 동작 수행
        - 방법 3. 파이썬 리스트 사용해 Stack 만들기
    - 스택 → 문자열 뒤집기
    - 최소 스택
        - 모든 스택의 동작 O(1)
        - 메인 스택과 최소 스택 사용
            - 메인 스택: 푸시와 팝 동작 지원
            - 최소 스택: 스택에서 가장 작은 요소만 추적