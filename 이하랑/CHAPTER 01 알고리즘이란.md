# CHAPTER 01 알고리즘이란?

PART: 01 알고리즘
상태: 완료

- **알고리즘** : 어떤 문제를 해결하기 위해 밟아 나가는 연속적인 단계
                  : 입력을 기반으로 출력을 생성하는 `명확(Definiteness)`하고, `효율적(Effectiveness)`이며 `유한(Finiteness)`한 프로세스
                 +`정확성(Correctness)`, `무작위성(Randomness)` . . .

## 알고리즘 분석

→ 여러 가지 알고리즘으로 문제 풀 수 있을 시, 최선의 알고리즘 찾아야 함

- 실행 시간
    
    ```python
    import time
    
    start = time.time()
    for i in range(1,6):
    	print(i)
    end = time.time()
    print(end - start)
    
    # 결과값1: 0.15141820907592773
    # 결과값2: 0.14856505393981934
    ```
    
    - 실행 시간에 영향을 미치는 요인
        - 프로그램 실행 순간 컴퓨터가 사용할 수 있는 CPU의 자원 (매번 다름)
        - 컴퓨터의 성능
        - 프로그래밍 언어 (ex. C > Python)
    
    → 여러가지 변수의 영향 받으므로 효과적인 기준 될 수 X.
    ∴ 알고리즘에 필요한 단계를 수식으로 비교함: f(n)
    
- f(n) → n: 데이터의 크기
T(n): 수학적 시간
    - for 은 n의 제곱 형태로 표현. (ex. n이 10일 시, 중첩 for문은 10**2로 표현)
    → 알고리즘에 필요한 단계 항상 정확하게 셀 수 X.
    - 데이터의 크기 n의 변화함에 따라 알고리즘의 성능이 어떻게 변화하는지 대략적으로 파악하는 것이 가장 중요. → 빅 O 표기법
- 빅 O 표기법 (Big O notation): n이 커짐에 따라 알고리즘의 시간 또는 공간의 요건이 얼마나 커지는지를 나타내는 수학적 표기법. T(n) 에서 규모 함수 도출.
    - 규모 (Order of Magnitude, 크기의 자릿수): 차이가 아주 큰 등급 체계에서의 크기 차이
    즉, T(n)에서 수식을 지배하는 부분만 남기고 나머지는 모두 무시함
    - T(n) = 3n^2+4n
    → 가장 지배적인 부분인 최고차항 3n^2을 제외한 4n과 3n^2 계수 3 제거
    → **∴** O(n^2): 빅 O 표기법에서 도출한 알고리즘의 규모
    - 규모 함수들의 순서(효율→비효율)
    `상수 시간` → `로그 시간` → `선형 시간` → `선형 로그 시간` → `2차 시간` → `3차 시간` → `지수 시간`
        
        ### 상수 시간
        
        - 상수 시간 복잡도 (Constant Time Complexity)
        어떤 알고리즘이 n의 크기에 관계없이 동일한 단계만 필요한 알고리즘
        즉, 데이터 세트가 아무리 커지더라도 알고리즘의 실행 시간 변하지 X
        - 빅 O 표기법: `0(1)`
            
            ![Untitled](https://github.com/user-attachments/assets/2a33a0df-cb56-4089-9834-738d087353a9)
            
        
        ### 로그 시간
        
        - 로그 시간 복잡도 (Logarithmic Time Complexity)
        데이터의 로그에 비례해 알고리즘의 단계가 늘어나는 알고리즘
        (ex. 실행 반복할 때마다 알고리즘의 탐색 범위를 1/2로 줄여 나가는 **이진 탐색**)
        - 빅 O 표기법: `0(log n)`
            
            ![Untitled](CHAPTER%2001%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A1%E1%86%AB%200f62f0a50e424bdea48ad5d5b6bd5a1a/Untitled%201.png)
            
        
        ### 선형 시간
        
        - 선형 시간 복잡도 (Linear Time Complexity)
        데이터 세트가 커지는 만큼 알고리즘의 실행에 필요한 단계도 같은 비율로 늘어나는 알고리즘
        - 빅 O 표기법: `0(n)`
            
            ![Untitled](CHAPTER%2001%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A1%E1%86%AB%200f62f0a50e424bdea48ad5d5b6bd5a1a/Untitled%202.png)
            
        
        ### 선형 로그 시간
        
        - 선형 로그 시간 (Log-Linear Time) 복잡도
        로그 시간 복잡도와 선형 시간 복잡도를 곱한만큼 커지는 알고리즘
        데이터 세트를 작은 부분으로 나누고, 이들을 독립적으로 처리하는 형태 
        (ex. **병합 정렬**과 같은 효율적인 정렬 알고리즘)
        - 빅 O 표기법: `0(n log n)`
            
            ![Untitled](CHAPTER%2001%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A1%E1%86%AB%200f62f0a50e424bdea48ad5d5b6bd5a1a/Untitled%203.png)
            
        
        ### 2차 시간
        
        - 2차 시간 복잡도 (Quadratic Time Complexity)
        n의 제곱에 정비례하는 알고리즘의 복잡도
        (ex. n의 제곱에 비례해 실행 시간이 늘어나는 **삽입 정렬**, **버블 정렬**과 같은 정렬 알고리즘)
        - 빅 O 표기법: `0(n**2)`
            
            ![Untitled](CHAPTER%2001%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A1%E1%86%AB%200f62f0a50e424bdea48ad5d5b6bd5a1a/Untitled%204.png)
            
        
        ### 3차 시간
        
        - 3차 시간(Cubic Time) 복잡도
        n의 세제곱에 정비례하는 알고리즘의 복잡도
        - 빅 O 표기법: `0(n**3)`
        
        → 다항 시간 복잡도 (Polynomial Time Complexity) : `0(n**a)`에 비례하여 커짐
            알고리즘 설계시 가급정 피하는 편이 좋음
            ∵ n이 커짐에 따라 실행 시간 급격하게 늘어나기 때문 
        
        ### 지수 시간
        
        - 지수 시간 복잡도 (Exponential Time Complexity)
        데이터 크기의 지수식으로 표현되는 알고리즘
        (ex. n개의 숫자로 이루어진 비밀번호의 가능한 모든 조합을 시도하는 무차별 대입 알고리즘(Brute-Force Algorithm))
        
        ```python
        pin = 931
        n = len(pin)
        for i in range (10**n):
        	if i == pin:
        		print (i)
        ```
        
        - 빅 O 표기법: `0(c**n)`
            
            ![Untitled](CHAPTER%2001%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A1%E1%86%AB%200f62f0a50e424bdea48ad5d5b6bd5a1a/Untitled%205.png)
            
- 최선과 최악
알고리즘의 실행 시간(성능)은 데이터의 종류를 비롯해 다양한 요인에 의해 변함.
→ 알고리즘의 성능 평가 시, 최선과 최악, 평균의 시간 복잡도 고려해야 함
    - 최선의 경우 (Best-case): 알고리즘에 입력되는 데이터가 이상적일 때
    - 최악의 경우 (Worst-case): 가능한 모든 시나리오 중 가장 최악(알고리즘의 실행 시간이 급격히 변화하는 경우)일 때
    - 평균의 경우 (Average-case): 알고리즘이 평균적으로 얼마나 빨리 실행되는지 나타냄 `0(n/2)` = `0(n)`

## 공간 복잡도

알고리즘의 실행을 완료할 때까지 필요한 자원의 양을 얼마나 사용하는지 나타냄.

- 고정 공간 (Fixed Space): 프로그램 자체가 차지하는 메모리
- 자료구조 공간 (data Structure Space): 데이터 세트.
(ex. 탐색의 대상이 되는 리스트를 저장하는 데 필요한 메모리)
→ n의 크기에 따라 달라짐
- 임시 공간 (Temporary Space): 알고리즘에서 중간 처리를 위해 사용하는 메모리.
(ex. 데이터 전송을 위해 임시로 리스트 사본을 만들 때 필요한 메모리)
- n의 팩토리얼은 상수 공간 복잡도인 `0(1)` 을 따름.
    
    ```python
    x = 1
    n = 5
    for i in range (1, n+1):
    	x = x * i
    ```
    
- if, n까지 도달하며 계산한 중간 결과를 모두 리스트에 저장할 시, 선형 공간 복잡도 `0(n)`을 따름.
    
    ```python
    x = 1
    n = 5
    a_list = []
    for i in range(1, n+1):
    	a_list.append(x)
    	x = x * i
    ```
    

→ 일반적으로 공간을 적게 쓸수록 Good

## 복잡도가 중요한 이유

알고리즘을 최적화하기 위해 중요한 것은 알고리즘의 규모를 줄이는 것임. 

알고리즘을 잘 선택하는 것이 속도면에서도 중요하지만 서비스 측면에서도 중요한 영향을 미침.

<aside>
💡 예전에 만들었던 프로그램을 찾아, 프로그램에 사용된 여러 가지 알고리즘의 시간 복잡도를 평가해 보세요.

</aside>
